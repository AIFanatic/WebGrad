import { Device } from "./Backend";
import { TensorBuffer } from "./TensorBuffer";
import { UnaryOps } from "./UnaryOps";
import { BinaryOps } from "./BinaryOps";
import { ReduceOps } from "./ReduceOps";

interface WEBGLKernelUniform {
    name: string;
    value: number | number[];
};

interface ITextureInfo {
    width: number;
    height: number;
    internalFormat: number;
    format: number;
    type: number;
}

export class Texture {
    public data: Float32Array | null;
    public readonly width: number;
    public readonly height: number;
    public readonly internalFormat: number;
    public readonly format: number;
    public readonly type: number;
    public readonly texture: WebGLTexture;

    constructor(data: Float32Array | null, info: ITextureInfo) {
        if (data === undefined) throw Error("Got undefined data");
    
        this.data = data;
        this.width = info.width;
        this.height = info.height;
        this.internalFormat = info.internalFormat;
        this.format = info.format;
        this.type = info.type;

        const gl = WEBGLContext.gl;

        if (data instanceof Texture) {
            if (!data.texture) throw Error("Passed texture but no data.texture found");
            gl.bindTexture(gl.TEXTURE_2D, data.texture);
            this.texture = data.texture;
        }
        else {
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, info.internalFormat, info.width, info.height, 0, info.format, info.type, data);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    
            this.texture = texture;
        }
    }

    public toString() {
        return `Texture(
            data=[${this.data}],
            width=${this.width},
            height=${this.height},
            internalFormat=${WEBGLContext.glCodeToStr(this.internalFormat)}
            format=${WEBGLContext.glCodeToStr(this.format)},
            type=${WEBGLContext.glCodeToStr(this.type)}
        )`
    }

    private decodeMatrixFromUnpackedArray(unpackedArray: Float32Array, matrix: Float32Array, channelsPerTexture: number) {
        function getMatrixSizeFromUnpackedArraySize(unpackedSize: number, channelsPerTexture: number): number {
            if (unpackedSize % channelsPerTexture !== 0) {
                throw new Error(`unpackedSize (${unpackedSize}) must be a multiple of ${channelsPerTexture}`);
            }
            return unpackedSize / channelsPerTexture;
        }

        const requiredSize = getMatrixSizeFromUnpackedArraySize(unpackedArray.length, channelsPerTexture);
        if (matrix.length < requiredSize) throw new Error(`matrix length (${matrix.length}) must be >= ${requiredSize}`);

        let dst = 0;
        for (let src = 0; src < unpackedArray.length; src += channelsPerTexture) {
            matrix[dst++] = unpackedArray[src];
        }
    }

    public read(): Float32Array {
        if (this.data) return this.data;

        this.data = WEBGLContext.readTextureData(this);
        if (!this.isPacked) {
            const matrix = new Float32Array(this.width * this.height * 1);
            this.decodeMatrixFromUnpackedArray(this.data, matrix, 4);
            this.data = matrix;
        }

        return this.data;
    }

    public static shapeTo2d(shape: number[]): [number, number] {
        let shape2d: [number, number] = [shape[0], 1];
        for (let i = 1; i < shape.length; i++) {
            shape2d[1] *= shape[i];
        }
        return shape2d;
    }

    // Computes the width and height necessary to fit in an RGBA texture.
    // For example if the shape is [3,3] the data size is 3*3=9.
    // If the texture is w=2,h=1, this only 2*1*4=8pixels, we need 9.
    // So the pixels need to be w=2,h=2 which is 2*2*4=16 (16-9=7 pixels are ignored).
    //
    // TODO: The height is being increased if the pixels still dont fit the data.
    //       Is this enought or are there any exceptions?
    public static calculateWidthAndHeightToFitShape(shape: number[], channels: number): [number, number] {
        const shape2D = Texture.shapeTo2d(shape);
        const prodShape = shape2D.reduce((p, c) => p * c)

        const width = Math.ceil(Math.sqrt(prodShape / channels));
        let height = Math.floor(Math.sqrt(prodShape / channels));

        if (width * height * channels < prodShape) height++;
        if (width * height * channels < prodShape) throw Error("Couldnt get enough pixels to compute.");

        return [width, height];
    }

    public static createUnpackedFromShape(data: Float32Array | null, shape: number[]): Texture {
        const gl = WEBGLContext.gl;
        const [width, height] = Texture.calculateWidthAndHeightToFitShape(shape, 1);
        if (data && data.length < width * height) {
            const shapeProd = shape.reduce((p, c) => p * c);
            const _data = new Float32Array(width * height);
            _data.set(data);
            data = _data;
        }
        return new Texture(data, { width: width, height: height, internalFormat: gl.R32F, format: gl.RED, type: gl.FLOAT });
    }

    public static createUnpackedFromDimensions(data: Float32Array | null, width: number, height: number): Texture {
        const gl = WEBGLContext.gl;
        return new Texture(data, { width: width, height: height, internalFormat: gl.R32F, format: gl.RED, type: gl.FLOAT });
    }
}

export class WEBGLContext {
    private static defaultVertexShader = `#version 300 es
    precision highp float;
    in vec3 clipSpacePos;
    in vec2 uv;
    out vec2 resultUV;

    void main() {
        gl_Position = vec4(clipSpacePos, 1);
        resultUV = uv;
    }`;

    private static glCodesTable;

    private static _gl: WebGL2RenderingContext;
    public static get gl(): WebGL2RenderingContext {
        if (!WEBGLContext._gl) WEBGLContext._gl = WEBGLContext.setup();
        return WEBGLContext._gl;
    }

    constructor() {
        throw Error("WEBGLContext is a singleton cannot call with new.");
    }

    private static setup(): WebGL2RenderingContext {
        if (typeof window === "undefined") throw Error("Window not found, WebGL2 is only supported in browsers.");
        if (typeof document === "undefined") throw Error("Document not found, WebGL2 is only supported in browsers.");

        const canvas = document.createElement("canvas");
        // canvas.width = 512;
        // canvas.height = 512;

        const gl = canvas.getContext("webgl2");
        if (!gl) throw Error("Could not setup WebGL2");
        if (!gl.getExtension("EXT_color_buffer_float")) throw Error("EXT_color_buffer_float not supported");

        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);

        document.body.appendChild(canvas);

        return gl;
    }

    private static compileShader(gl: WebGL2RenderingContext, shaderType: WebGLRenderingContextBase["VERTEX_SHADER"] | WebGLRenderingContextBase["FRAGMENT_SHADER"], shaderCode: string): WebGLShader {
        const shader = gl.createShader(shaderType);
        gl.shaderSource(shader, shaderCode);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.log(`${shaderCode}`);
            throw new Error('Could not compile shader: ' + gl.getShaderInfoLog(shader));
        }

        return shader;
    }

    private static createShaderProgram(gl: WebGL2RenderingContext, vertexShader: WebGLShader, fragmentShader: WebGLShader): WebGLProgram {
        const shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);

        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            const linkErrLog = gl.getProgramInfoLog(shaderProgram);
            throw Error(`Shader program did not link successfully. Error: ${linkErrLog}`);
        }

        return shaderProgram;
    }

    private static createQuad(gl: WebGL2RenderingContext, program: WebGLProgram): WebGLBuffer {
        const vertex_data = new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]);
        const vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertex_data, gl.STATIC_DRAW);

        const posOffset = 0;               // x is the first buffer element
        const uvOffset = 3 * 4;            // uv comes after [x y z]
        const stride = (3 * 4) + (2 * 4);  // xyz + uv, each entry is 4-byte float.

        const clipSpacePosLoc = gl.getAttribLocation(program, "clipSpacePos");
        gl.vertexAttribPointer(clipSpacePosLoc, 3, gl.FLOAT, false, stride, posOffset);
        gl.enableVertexAttribArray(clipSpacePosLoc);

        const uvLoc = gl.getAttribLocation(program, "uv");
        gl.vertexAttribPointer(uvLoc, 2, gl.FLOAT, false, stride, uvOffset);
        gl.enableVertexAttribArray(uvLoc);

        return vertexBuffer;
    }

    private static bindTexture(gl: WebGL2RenderingContext, texture: WebGLTexture, program: WebGLProgram, location: number): WebGLUniformLocation {
        gl.activeTexture(gl.TEXTURE0 + location);
        gl.bindTexture(gl.TEXTURE_2D, texture);
        const textureLocation = gl.getUniformLocation(program, `u_tex${location}`);
        gl.uniform1i(textureLocation, location); // Texture unit 0
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.uniform1i(textureLocation, location);

        return textureLocation;
    }

    private static processUniforms(gl: WebGL2RenderingContext, program: WebGLProgram, uniforms: WEBGLKernelUniform[]) {
        if (!uniforms) return;

        for (let i = 0; i < uniforms.length; i++) {
            const name = uniforms[i].name;
            const value = uniforms[i].value;

            const location = gl.getUniformLocation(program, name);
            // TODO: Only float vectors
            if (value instanceof Array) {
                if (value.length == 2) gl.uniform2f(location, value[0], value[1]);
                else if (value.length == 3) gl.uniform3f(location, value[0], value[1], value[2]);
                else if (value.length == 4) gl.uniform4f(location, value[0], value[1], value[2], value[3]);
                else throw Error("When passing array uniforms the maximum length cannot exceed 4");
            }
            else {
                if (Number.isInteger(value)) gl.uniform1i(location, value);
                else gl.uniform1f(location, value);
            }
        }
    }

    public static runKernel(shader: string, inputs: Texture[], output: Texture, uniforms?: WEBGLKernelUniform[]): void {
        if (inputs.length === 0) throw Error("Cannot run kernel without any buffers.");

        const gl = WEBGLContext.gl;

        const vertexShader = WEBGLContext.compileShader(gl, gl.VERTEX_SHADER, WEBGLContext.defaultVertexShader);
        const fragmentShader = WEBGLContext.compileShader(gl, gl.FRAGMENT_SHADER, shader);

        const shaderProgram = WEBGLContext.createShaderProgram(gl, vertexShader, fragmentShader);

        const quadVertexBuffer = WEBGLContext.createQuad(gl, shaderProgram);

        gl.useProgram(shaderProgram);

        WEBGLContext.processUniforms(gl, shaderProgram, uniforms);

        gl.clearColor(0, 0, 0, 0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.viewport(0, 0, output.width, output.height);

        WEBGLContext.bindTexture(gl, output.texture, shaderProgram, 0);

        // Create and bind the framebuffer
        const fb = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, output.texture, 0);

        for (let i = 0; i < inputs.length; i++) {
            const bufferLocation = WEBGLContext.bindTexture(gl, inputs[i].texture, shaderProgram, i);
        }

        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }

    public static readTextureData(texture: Texture): Float32Array {
        const gl = WEBGLContext.gl;
        const framebuffer = gl.createFramebuffer();

        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture.texture, 0);

        if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE) throw Error("Framebuffer incomplete");

        const data = new Float32Array(texture.width * texture.height * 4);
        gl.readBuffer(gl.COLOR_ATTACHMENT0);
        gl.readPixels(0, 0, texture.width, texture.height, gl.RGBA, gl.FLOAT, data);
        // console.log("readPixels", data);

        // Clean up
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.deleteFramebuffer(framebuffer);

        return data;
    }

    public static glCodeToStr(code) {
        if (!WEBGLContext.glCodesTable) {
            WEBGLContext.glCodesTable = {};
            for (var key in WEBGLContext.gl) {
                WEBGLContext.glCodesTable[WEBGLContext.gl[key]] = key;
            }
        }
        return "gl." + WEBGLContext.glCodesTable[code];
    }
}

export class WEBGLBuffer extends TensorBuffer {
    public readonly shape: number[];
    public readonly strides: number[];
    public readonly offset: number;

    public data: Float32Array;
    public texture: Texture;

    constructor(data: WEBGLBuffer | Texture | Float32Array, shape: number[], strides: number[], offset: number) {
        if (!data || data === null) throw Error("Cannot create buffer with no data");

        super(shape, strides, offset, Device.WEBGL);
        if (data instanceof Float32Array) this.data = data;
        if (data instanceof Texture) this.texture = data;
        if (data instanceof WEBGLBuffer) {
            if (!data.data && !data.texture) throw Error("Tried to create WEBGLBuffer with no data or texture.");
            if (data.data) this.data = data.data;
            else if (data.texture) this.texture = data.texture;
        }
    }

    public static CreateFromArray(array: Array<any>): WEBGLBuffer {
        const data = Float32Array.from(array.flat(Infinity));
        const shape = TensorBuffer.computeShape(array);
        const strides = TensorBuffer.computeStrides(shape);
        return new WEBGLBuffer(data, shape, strides, 0);
    }

    public static CreateFromFloat32Array(data: Float32Array, shape: number[] = [], strides: number[] = [], offset: number = 0): WEBGLBuffer {
        const _shape = shape.length === 0 ? [data.length] : shape;
        const _strides = strides.length === 0 ? this.computeStrides(_shape) : strides;
        return new WEBGLBuffer(data, _shape, _strides, offset);
    }

    public static CreateFromNumber(num: number): WEBGLBuffer {
        return new WEBGLBuffer(new Float32Array([num]), [1], [1], 0);
    }

    protected getInternalData(): Float32Array {
        return this.data ? this.data : this.texture.read();
    }

    public createUnpackedTexture(): Texture {
        if (!this.data && !this.texture) throw Error("Tried to create unpacked texture without a data or texture field");

        if (this.texture) return this.texture;
        else if (this.data) {
            this.texture = Texture.createUnpackedFromShape(this.data, this.shape);
        }
        return this.texture;
    }

    public createUnpackedTextureFromDimensions(width: number, height: number): Texture {
        if (!this.data && !this.texture) throw Error("Tried to create unpacked texture without a data or texture field");

        if (this.texture) {
            if (this.texture.data) {
                this.texture = Texture.createUnpackedFromDimensions(this.texture.data, width, height);    
            }
            return this.texture;
        }
        else if (this.data) {
            this.texture = Texture.createUnpackedFromDimensions(this.data, width, height);
        }
        return this.texture;
    }
    
    public unary_op(op: UnaryOps): WEBGLBuffer {
        function processOp(op: UnaryOps): string {
            if (op === UnaryOps.ABS) return "abs(t1)";
            else if (op === UnaryOps.EXP) return "exp(t1)";
            else if (op === UnaryOps.TANH) return "tanh(t1)";
        }

        const inputTexture = this.createUnpackedTexture();
        const outputTexture = Texture.createUnpackedFromShape(null, this.shape);

        WEBGLContext.runKernel(`#version 300 es
        precision mediump float;
        
        uniform sampler2D u_tex0;

        out vec4 result;
        
        void main() {
            ivec2 coords = ivec2(gl_FragCoord.xy);
            vec4 t1 = texelFetch(u_tex0, coords, 0);

            result = ${processOp(op)};
        }`, [inputTexture], outputTexture);

        return new WEBGLBuffer(outputTexture, this.shape, this.strides, this.offset);
    }

    public binary_op(other: WEBGLBuffer, op: BinaryOps): WEBGLBuffer {
        function processOp(op: BinaryOps): string {
            if (op === BinaryOps.ADD) return "t1 + t2";
            else if (op === BinaryOps.SUB) return "t1 - t2";
            else if (op === BinaryOps.MUL) return "t1 * t2";
            else if (op === BinaryOps.DIV) return "t1 / t2";
            else if (op === BinaryOps.POW) return "pow(t1, t2)";
            else if (op === BinaryOps.CMPEQ) return "vec4(t1.r == t2.r, t1.g == t2.g, t1.b == t2.b, t1.a == t2.a)";
            else if (op === BinaryOps.MAX) return "max(t1, t2)";
        }

        const inputTextureX = this.createUnpackedTexture();
        const inputTextureY = other.createUnpackedTexture();
        const outputTexture = Texture.createUnpackedFromShape(null, this.shape);

        WEBGLContext.runKernel(`#version 300 es
        precision mediump float;

        uniform sampler2D u_tex0;
        uniform sampler2D u_tex1;

        out vec4 result;

        void main() {
            ivec2 coords = ivec2(gl_FragCoord.xy);
            vec4 t1 = texelFetch(u_tex0, coords, 0);
            vec4 t2 = texelFetch(u_tex1, coords, 0);
        
            result = ${processOp(op)};
        }`, [inputTextureX, inputTextureY], outputTexture);

        return new WEBGLBuffer(outputTexture, this.shape, this.strides, this.offset);
    }

    // public reduce_op(op: ReduceOps, axis: number, inputShape: number[], resultShape: number[]): WEBGLBuffer {
    //     console.time("reduce_op");
    //     function prod(array: number[]): number {
    //         return array.reduce((p, c) => p * c);
    //     }

    //     const axisLength = axis === null ? prod(this.shape) : this.shape[this.shape.length-1];

    //     function sumDim(input: Texture, prevPassTexture: Texture, shape: number[], pass: number, chunkSize: number): Texture {
    //         const outputTexture = Texture.createUnpackedFromShape(null, shape);

    //         // const uniforms: WEBGLKernelUniform[] = [
    //         //     {name: "u_pass", value: pass},
    //         //     {name: "u_chunkSize", value: chunkSize},
    //         //     {name: "width", value: outputTexture.width},
    //         //     {name: "u_axisLength", value: axisLength},
    //         // ];

    //         const inputTextures = prevPassTexture === null ? [input] : [input, prevPassTexture];
    //         WEBGLContext.runKernel(`#version 300 es
    //         precision mediump float;
    
    //         uniform sampler2D u_tex0;          // Main texture
    //         uniform sampler2D u_tex1;          // Texture from previous pass (either texA or texB)
    //         const int u_pass = ${pass};                // Current pass number
    //         const int u_chunkSize = ${chunkSize};           // Number of items processed in each pass
    //         const int width = ${outputTexture.width};
    //         const int u_axisLength = ${axisLength};

    //         // uniform int u_pass;
    //         // uniform int u_chunkSize;
    //         // uniform int width;
    //         // uniform int u_axisLength;

            
    //         out float result;

    //         ivec2 getIndexCoords(int index) {
    //             return ivec2(index % width, index / width);
    //         }

    //         void main() {
    //             int index = int(gl_FragCoord.x) + int(gl_FragCoord.y) * width;

    //             int startIndex = index * u_axisLength + u_pass * u_chunkSize;
    //             float sum = 0.0;
            
    //             if (u_pass != 0) {
    //                 sum = texelFetch(u_tex1, ivec2(gl_FragCoord.xy), 0).r;
    //             }
            
    //             for (int i = 0; i < u_chunkSize && (startIndex + i) < (index + 1) * u_axisLength; i++) {
    //                 ivec2 coords = getIndexCoords(startIndex + i);
    //                 sum += texelFetch(u_tex0, coords, 0).r;
    //             }
            
    //             result = sum;
    //         }`, inputTextures, outputTexture);

    //         return outputTexture;
    //     }
    //     const chunkSize = 1024 * 1024;
    //     const inputTexture = this.createUnpackedTexture();
    //     const totalPasses = Math.ceil(axisLength / chunkSize)

    //     console.log(`chunkSize ${chunkSize} totalPasses ${totalPasses}`);
    //     let outputTexture: Texture = null;
    //     for (let pass = 0; pass < totalPasses; pass++) {
    //         outputTexture = sumDim(inputTexture, outputTexture, this.shape, pass, chunkSize);
    //     }
    //     outputTexture.read()
    //     console.timeEnd("reduce_op");
    //     return new WEBGLBuffer(outputTexture, resultShape, TensorBuffer.computeStrides(resultShape), this.offset);
    // }

    public reduce_op(op: ReduceOps, axis: number, inputShape: number[], resultShape: number[]): WEBGLBuffer {
        // console.time("reduce_op");

        const webglOp = op === ReduceOps.SUM ? "+" : "*";

        function prod(array: number[]): number {
            return array.reduce((p, c) => p * c);
        }

        const axisLength = axis === null ? prod(this.shape) : this.shape[this.shape.length-1];

        function sumDim(input: Texture, shape: number[], stride: number): Texture {
            const outputTexture = Texture.createUnpackedFromShape(null, shape);

            // const uniforms: WEBGLKernelUniform[] = [
            //     {name: "width", value: outputTexture.width},
            //     {name: "u_stride", value: stride},
            //     {name: "u_axisLength", value: axisLength},
            // ];

            WEBGLContext.runKernel(`#version 300 es
            precision mediump float;
            
            uniform sampler2D u_tex0;

            const int width = ${outputTexture.width};
            const int u_stride = ${stride}; // The distance between elements being combined.
            const int u_axisLength = ${axisLength};
            
            out float result;

            ivec2 getIndexCoords(int index) {
                return ivec2(index % width, index / width);
            }

            float getByIndex(int index) {
                ivec2 coords = getIndexCoords(index);
                return texelFetch(u_tex0, coords, 0).r;
            }

            int getIndexAxis(int index) {
                return int(floor(float(index) / float(u_axisLength)));
            }
            
            bool indexInsideAxis(int index, int axis) {
                return getIndexAxis(index) == axis;
            }
            
            void main() {
                int index = int(gl_FragCoord.x) + int(gl_FragCoord.y) * width;

                int t1Index = index;
                int t2Index = index + u_stride;
                int t1Axis = getIndexAxis(t1Index);
                int t2Axis = getIndexAxis(t2Index);
                
                ivec2 t1 = getIndexCoords(t1Index);
                ivec2 t2 = getIndexCoords(t2Index);

                if (t1Axis != t2Axis) {
                    float value1 = texelFetch(u_tex0, t1, 0).r;
                    result = value1;
                    return;
                }
            
                float value1 = texelFetch(u_tex0, t1, 0).r;
                float value2 = texelFetch(u_tex0, t2, 0).r;
            
                result = value1 ${webglOp} value2; // For summing values.
            }`, [input], outputTexture);

            return outputTexture;
        }
        const inputTexture = this.createUnpackedTexture();
        let outputTexture: Texture = inputTexture;
        let stride = 1; // Starting with adjacent elements.

        const totalNumberOfElements = prod(this.shape);
        while (stride < totalNumberOfElements) {
            // console.log(outputTexture.read())
            outputTexture = sumDim(outputTexture, this.shape, stride);
            stride *= 2;
        }


        const outputTexturePacked = Texture.createUnpackedFromShape(null, this.shape);
        // Pack data
        WEBGLContext.runKernel(`#version 300 es
        precision mediump float;

        uniform sampler2D u_tex0;

        const int u_axisLength = ${axisLength};
        const int width = ${outputTexturePacked.width};

        out float result;

        ivec2 getIndexCoords(int index) {
            return ivec2(index % width, index / width);
        }

        void main() {
            int index = int(gl_FragCoord.x) + int(gl_FragCoord.y) * width;
            ivec2 coords = getIndexCoords(index * u_axisLength);
            vec4 t1 = texelFetch(u_tex0, coords, 0);
        
            result = t1.r;
        }`, [outputTexture], outputTexturePacked);

        // console.timeEnd("reduce_op");
        return new WEBGLBuffer(outputTexturePacked, resultShape, TensorBuffer.computeStrides(resultShape), this.offset);
    }

    public contiguous(): WEBGLBuffer {
        // throw Error("CALLED CONTIGUOS");
        const inputTexture = this.createUnpackedTexture();
        const outputTexture = Texture.createUnpackedFromShape(null, this.shape);

        const MAX_DIMS = 10;
        if (this.shape.length !== this.strides.length) throw Error("Shape does not match strides");
        if (this.shape.length > MAX_DIMS) throw Error(`Maximum dimensions for contiguous call are 10, got ${this.shape.length}`);

        let shapeArrayStr = "";
        let strideArrayStr = "";
        for (let i = 0; i < MAX_DIMS; i++) {
            shapeArrayStr += `${this.shape[i] ? this.shape[i] : "0"}` + ",";
            strideArrayStr += `${this.strides[i] ? this.strides[i] : "0"}` + ",";
        }
        shapeArrayStr = shapeArrayStr.slice(0, shapeArrayStr.length-1);
        strideArrayStr = strideArrayStr.slice(0, strideArrayStr.length-1);

        WEBGLContext.runKernel(`#version 300 es
        precision mediump float;

        uniform sampler2D u_tex0;

        in vec2 resultUV;
        out float result;
        
        const int[10] shape1 = int[](${shapeArrayStr});
        const int[10] strides1 = int[](${strideArrayStr});
        const int offset1 = ${this.offset};

        const int width1 = ${inputTexture.width};
        const int height1 = ${inputTexture.height};

        const int MAX_DIMS = ${MAX_DIMS};

        float getData(sampler2D tensor, int width, int i, int offset, int[MAX_DIMS] shape, int[MAX_DIMS] strides, int numDims) {
            int idx = 0;
            int totalSize = 1;
        
            for (int j = 0; j < numDims; ++j) {
                totalSize *= shape[j];
            }
        
            for (int dim = 0; dim < numDims; ++dim) {
                totalSize /= shape[dim];
                int coord = int(i / totalSize);
                i -= coord * totalSize;
                idx += strides[dim] * coord;
            }
            idx += offset;
        
            ivec2 coords = ivec2(idx % width, idx / width);
            return texelFetch(tensor, coords, 0).r;
        }

        void main() {
            int index = int(gl_FragCoord.x) + int(gl_FragCoord.y) * width1;
            float d = getData(u_tex0, width1, index, offset1, shape1, strides1, ${this.shape.length});
            result = d;
        }`, [inputTexture], outputTexture);

        const v = this;
        const r = new WEBGLBuffer(outputTexture, this.shape, TensorBuffer.computeStrides(this.shape), this.offset);
        function d() {
            console.log(`
                contiguous output:
                    data: ${r}
                    expected output: ${v}
                    readPixels: ${outputTexture.read()} 
                `);
        }

        // d()
        // r.getInternalData()
        // console.log("");
        return r;
    }





    public toString() {
        function fixed(key, val) {
            return val.toFixed ? Number(val.toFixed(4)) : val;
        }
        return JSON.stringify(this.getData(), fixed)
    }

    public copy(): WEBGLBuffer {
        throw Error("Not implemented");
    }
}